<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Simulador BFS para Dígrafos</title>
<style>
  body { font-family: Arial, sans-serif; margin: 20px; background: #f5f5f5; }
  .container { max-width: 1400px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1); }
  h2 { color: #333; }
  .controls { margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 5px; }
  label { font-weight: bold; margin-right: 10px; }
  input[type=number] { width: 80px; font-size: 16px; padding: 5px; margin-right: 15px; }
  button { font-size: 16px; padding: 8px 15px; margin: 5px; cursor: pointer; background: #4CAF50; color: white; border: none; border-radius: 4px; }
  button:hover { background: #45a049; }
  button:disabled { background: #ccc; cursor: not-allowed; }
  .step-button { background: #2196F3; }
  .step-button:hover { background: #0b7dda; }
  .reset-button { background: #f44336; }
  .reset-button:hover { background: #da190b; }
  .canvas-container { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; }
  canvas { border: 2px solid #ddd; margin: 10px 0; background: white; display: block; width: 100%; }
  #queue-canvas { grid-column: 1 / -1; }
  #output { margin-top: 20px; white-space: pre-wrap; font-family: monospace; border: 1px solid #ddd; padding: 15px; background: #f9f9f9; max-height: 300px; overflow-y: auto; font-size: 14px; }
  .state-display { margin: 15px 0; padding: 15px; background: #e3f2fd; border-left: 4px solid #2196F3; border-radius: 4px; }
  .state-display h3 { margin-top: 0; color: #1976D2; }
  .var-display { display: inline-block; margin: 5px 15px 5px 0; padding: 5px 10px; background: white; border-radius: 3px; font-family: monospace; }
  .queue-display { background: #fff9c4; padding: 10px; border-radius: 4px; margin: 10px 0; }
  .canvas-label { font-weight: bold; color: #555; margin-top: 10px; }
  .forest-label { background: #e8f5e9; padding: 5px 10px; border-radius: 4px; margin: 5px 0; display: inline-block; }
</style>
</head>
<body>
<div class="container">
<h2>Simulador BFS para Dígrafos (Orientados)</h2>

<div class="controls">
  <label for="numVertices">Número de vértices:</label>
  <input type="number" id="numVertices" value="8" min="3" max="12" />
  <button onclick="generateRandomDigraph()">Gerar Dígrafo Aleatório</button>
  <button onclick="loadDefaultDigraph()">Carregar Dígrafo Padrão</button>
  <button class="step-button" id="stepBtn" onclick="stepSimulation()" disabled>Próximo Passo</button>
  <button class="reset-button" onclick="resetSimulation()">Reiniciar</button>
</div>

<div class="canvas-container">
  <div>
    <div class="canvas-label">Dígrafo (orientado):</div>
    <canvas id="graph-canvas" width="650" height="500"></canvas>
  </div>
  <div>
    <div class="canvas-label">Floresta de Árvores BFS:</div>
    <div id="treeLabels"></div>
    <canvas id="tree-canvas" width="650" height="500"></canvas>
  </div>
</div>

<div class="canvas-label">Visualização da Fila:</div>
<canvas id="queue-canvas" width="1300" height="120"></canvas>

<div class="state-display" id="stateDisplay" style="display:none;">
  <h3>Estado Atual</h3>
  <div id="variables"></div>
  <div class="queue-display">
    <strong>Fila (queue):</strong> <span id="queueContent">[]</span>
  </div>
</div>

<div id="output"></div>
</div>

<script>
let vertices = [];
let edges = [];
let adjList = {};
let marked = {};
let expl = {};
let queue = [];
let cont = 0;
let curr = null;
let steps = [];
let stepIndex = 0;
let simulationStarted = false;
let canvas, ctx, queueCanvas, queueCtx, treeCanvas, treeCtx;
let treeEdges = [];
let treeRoots = [];
let currentBFSRoot = null;
let isDefaultGraph = false;

function init() {
  canvas = document.getElementById('graph-canvas');
  ctx = canvas.getContext('2d');
  queueCanvas = document.getElementById('queue-canvas');
  queueCtx = queueCanvas.getContext('2d');
  treeCanvas = document.getElementById('tree-canvas');
  treeCtx = treeCanvas.getContext('2d');
  loadDefaultDigraph();
}

function loadDefaultDigraph() {
  isDefaultGraph = true;
  vertices = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  
  // Arestas CORRIGIDAS do dígrafo padrão
  let edgeList = [
    // Do vértice 1
    [1, 4], [1, 5], [1, 9],
    // Do vértice 2
    [2, 3], [2, 9],
    // Do vértice 3
    [3, 6], [3, 9],
    // Do vértice 4
    [4, 5],
    // Do vértice 5
    [5, 9],
    // Do vértice 6
    [6, 8], [6, 9],
    // Do vértice 7
    [7, 3],
    // Do vértice 8
    [8, 9],
    // Do vértice 10
    [10, 3], [10, 6], [10, 8]
  ];
  
  buildDigraphFromEdges(edgeList);
}

function generateRandomDigraph() {
  isDefaultGraph = false;
  let n = parseInt(document.getElementById('numVertices').value);
  if (n < 3 || n > 12) {
    alert('Escolha entre 3 e 12 vértices');
    return;
  }
  
  vertices = [];
  for (let i = 1; i <= n; i++) {
    vertices.push(i);
  }
  
  let edgeList = [];
  
  for (let i = 1; i <= n; i++) {
    let numEdges = Math.floor(Math.random() * 3) + 1;
    for (let e = 0; e < numEdges; e++) {
      let to = Math.floor(Math.random() * n) + 1;
      if (i !== to && !edgeList.some(edge => edge[0] === i && edge[1] === to)) {
        edgeList.push([i, to]);
      }
    }
  }
  
  buildDigraphFromEdges(edgeList);
}

function buildDigraphFromEdges(edgeList) {
  edges = edgeList;
  
  adjList = {};
  for (let v of vertices) {
    adjList[v] = [];
  }
  
  for (let [u, v] of edges) {
    if (!adjList[u].includes(v)) {
      adjList[u].push(v);
    }
  }
  
  for (let v of vertices) {
    adjList[v].sort((a, b) => a - b);
  }
  
  drawGraph();
  drawTree();
  drawQueue();
  resetSimulation();
  document.getElementById('stepBtn').disabled = false;
}

function drawGraph() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  
  let radius = 20;
  let positions = {};
  
  if (isDefaultGraph && vertices.length === 10) {
    // Layout fixo para o dígrafo padrão
    positions = {
      1: { x: 150, y: 100 },
      4: { x: 70, y: 200 },
      5: { x: 150, y: 300 },
      9: { x: 280, y: 200 },
      2: { x: 350, y: 80 },
      3: { x: 450, y: 150 },
      8: { x: 280, y: 350 },
      6: { x: 450, y: 250 },
      7: { x: 570, y: 100 },
      10: { x: 570, y: 280 }
    };
  } else {
    // Layout em círculo para grafos aleatórios
    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;
    let circleRadius = Math.min(centerX, centerY) - 50;
    let n = vertices.length;
    
    for (let i = 0; i < n; i++) {
      let angle = (2 * Math.PI * i) / n - Math.PI / 2;
      positions[vertices[i]] = {
        x: centerX + circleRadius * Math.cos(angle),
        y: centerY + circleRadius * Math.sin(angle)
      };
    }
  }
  
  // Desenhar arestas direcionadas
  ctx.strokeStyle = '#666';
  ctx.lineWidth = 2;
  
  for (let [from, to] of edges) {
    let fromPos = positions[from];
    let toPos = positions[to];
    
    let angle = Math.atan2(toPos.y - fromPos.y, toPos.x - fromPos.x);
    let arrowX = toPos.x - radius * Math.cos(angle);
    let arrowY = toPos.y - radius * Math.sin(angle);
    
    ctx.beginPath();
    ctx.moveTo(fromPos.x, fromPos.y);
    ctx.lineTo(arrowX, arrowY);
    ctx.stroke();
    
    // Ponta da seta
    ctx.beginPath();
    ctx.moveTo(arrowX, arrowY);
    ctx.lineTo(arrowX - 12 * Math.cos(angle - Math.PI / 6), 
               arrowY - 12 * Math.sin(angle - Math.PI / 6));
    ctx.moveTo(arrowX, arrowY);
    ctx.lineTo(arrowX - 12 * Math.cos(angle + Math.PI / 6), 
               arrowY - 12 * Math.sin(angle + Math.PI / 6));
    ctx.stroke();
  }
  
  // Desenhar vértices
  for (let v of vertices) {
    let pos = positions[v];
    
    if (marked[v]) {
      ctx.fillStyle = '#4CAF50';
    } else if (curr === v) {
      ctx.fillStyle = '#FFC107';
    } else if (queue.includes(v)) {
      ctx.fillStyle = '#2196F3';
    } else {
      ctx.fillStyle = '#fff';
    }
    
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    ctx.fill();
    ctx.stroke();
    
    ctx.fillStyle = '#000';
    ctx.font = 'bold 16px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(v, pos.x, pos.y);
    
    if (expl[v] !== undefined) {
      ctx.fillStyle = '#c62828';
      ctx.font = 'bold 14px Arial';
      ctx.fillText(expl[v], pos.x + 25, pos.y - 5);
    }
  }
}

function drawTree() {
  treeCtx.clearRect(0, 0, treeCanvas.width, treeCanvas.height);
  
  let labelsHtml = '';
  for (let i = 0; i < treeRoots.length; i++) {
    labelsHtml += `<span class="forest-label">Árvore ${i + 1}: raiz = ${treeRoots[i]}</span> `;
  }
  document.getElementById('treeLabels').innerHTML = labelsHtml;
  
  if (treeEdges.length === 0) {
    treeCtx.fillStyle = '#999';
    treeCtx.font = '14px Arial';
    treeCtx.textAlign = 'center';
    treeCtx.fillText('Floresta será construída durante a travessia', treeCanvas.width / 2, treeCanvas.height / 2);
    return;
  }
  
  let radius = 20;
  let positions = calculateForestPositions();
  
  treeCtx.strokeStyle = '#2196F3';
  treeCtx.lineWidth = 2;
  
  for (let [from, to] of treeEdges) {
    let fromPos = positions[from];
    let toPos = positions[to];
    
    if (!fromPos || !toPos) continue;
    
    treeCtx.beginPath();
    treeCtx.moveTo(fromPos.x, fromPos.y);
    treeCtx.lineTo(toPos.x, toPos.y);
    treeCtx.stroke();
  }
  
  for (let v of vertices) {
    if (!positions[v]) continue;
    
    let pos = positions[v];
    
    if (expl[v] !== undefined) {
      treeCtx.fillStyle = '#4CAF50';
    } else {
      treeCtx.fillStyle = '#fff';
    }
    
    treeCtx.strokeStyle = '#333';
    treeCtx.lineWidth = 2;
    treeCtx.beginPath();
    treeCtx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);
    treeCtx.fill();
    treeCtx.stroke();
    
    treeCtx.fillStyle = '#000';
    treeCtx.font = 'bold 16px Arial';
    treeCtx.textAlign = 'center';
    treeCtx.textBaseline = 'middle';
    treeCtx.fillText(v, pos.x, pos.y);
  }
}

function calculateForestPositions() {
  let positions = {};
  let levels = {};
  let treeAssignment = {};
  
  for (let i = 0; i < treeRoots.length; i++) {
    let root = treeRoots[i];
    treeAssignment[root] = i;
    levels[root] = 0;
  }
  
  for (let [from, to] of treeEdges) {
    if (levels[from] !== undefined) {
      levels[to] = levels[from] + 1;
      treeAssignment[to] = treeAssignment[from];
    }
  }
  
  let treeCounts = {};
  let levelCounts = {};
  
  for (let v in treeAssignment) {
    let tree = treeAssignment[v];
    let level = levels[v];
    
    if (!treeCounts[tree]) treeCounts[tree] = 0;
    treeCounts[tree]++;
    
    let key = `${tree}-${level}`;
    if (!levelCounts[key]) levelCounts[key] = 0;
    levelCounts[key]++;
  }
  
  let treeStartX = 50;
  let treeSpacing = treeCanvas.width / (treeRoots.length + 1);
  let verticalSpacing = 80;
  let startY = 50;
  let levelIndices = {};
  
  for (let v in treeAssignment) {
    let tree = treeAssignment[v];
    let level = levels[v];
    let key = `${tree}-${level}`;
    
    if (!levelIndices[key]) levelIndices[key] = 0;
    
    let totalInLevel = levelCounts[key];
    let horizontalSpacing = treeSpacing * 0.8 / (totalInLevel + 1);
    let treeX = treeStartX + tree * treeSpacing;
    
    positions[v] = {
      x: treeX + horizontalSpacing * (levelIndices[key] + 1),
      y: startY + level * verticalSpacing
    };
    
    levelIndices[key]++;
  }
  
  return positions;
}

function drawQueue() {
  queueCtx.clearRect(0, 0, queueCanvas.width, queueCanvas.height);
  
  queueCtx.fillStyle = '#333';
  queueCtx.font = 'bold 16px Arial';
  queueCtx.textAlign = 'left';
  queueCtx.fillText('Fila (Queue):', 20, 25);
  
  if (queue.length === 0) {
    queueCtx.fillStyle = '#999';
    queueCtx.font = '14px Arial';
    queueCtx.fillText('[ vazia ]', 150, 25);
    return;
  }
  
  let boxWidth = 60;
  let boxHeight = 50;
  let startX = 150;
  let startY = 40;
  let spacing = 10;
  
  queueCtx.fillStyle = '#666';
  queueCtx.font = '12px Arial';
  queueCtx.textAlign = 'center';
  queueCtx.fillText('FRONT', startX + boxWidth / 2, startY - 10);
  
  for (let i = 0; i < queue.length; i++) {
    let x = startX + i * (boxWidth + spacing);
    
    queueCtx.fillStyle = '#2196F3';
    queueCtx.fillRect(x, startY, boxWidth, boxHeight);
    
    queueCtx.strokeStyle = '#1565C0';
    queueCtx.lineWidth = 2;
    queueCtx.strokeRect(x, startY, boxWidth, boxHeight);
    
    queueCtx.fillStyle = '#fff';
    queueCtx.font = 'bold 24px Arial';
    queueCtx.textAlign = 'center';
    queueCtx.textBaseline = 'middle';
    queueCtx.fillText(queue[i], x + boxWidth / 2, startY + boxHeight / 2);
    
    if (i < queue.length - 1) {
      queueCtx.strokeStyle = '#666';
      queueCtx.lineWidth = 2;
      queueCtx.beginPath();
      queueCtx.moveTo(x + boxWidth + 2, startY + boxHeight / 2);
      queueCtx.lineTo(x + boxWidth + spacing - 2, startY + boxHeight / 2);
      queueCtx.stroke();
      
      queueCtx.beginPath();
      queueCtx.moveTo(x + boxWidth + spacing - 2, startY + boxHeight / 2);
      queueCtx.lineTo(x + boxWidth + spacing - 6, startY + boxHeight / 2 - 4);
      queueCtx.moveTo(x + boxWidth + spacing - 2, startY + boxHeight / 2);
      queueCtx.lineTo(x + boxWidth + spacing - 6, startY + boxHeight / 2 + 4);
      queueCtx.stroke();
    }
  }
  
  let lastX = startX + (queue.length - 1) * (boxWidth + spacing);
  queueCtx.fillStyle = '#666';
  queueCtx.font = '12px Arial';
  queueCtx.textAlign = 'center';
  queueCtx.fillText('REAR', lastX + boxWidth / 2, startY + boxHeight + 15);
}

function resetSimulation() {
  marked = {};
  expl = {};
  queue = [];
  cont = 0;
  curr = null;
  steps = [];
  stepIndex = 0;
  simulationStarted = false;
  treeEdges = [];
  treeRoots = [];
  currentBFSRoot = null;
  
  document.getElementById('output').textContent = '';
  document.getElementById('stateDisplay').style.display = 'none';
  document.getElementById('treeLabels').innerHTML = '';
  
  if (vertices.length > 0) {
    prepareSimulation();
    drawGraph();
    drawTree();
    drawQueue();
  }
}

function prepareSimulation() {
  steps = [];
  
  steps.push({ type: 'init', message: 'Iniciando TravessiaBFS(1)' });
  steps.push({ type: 'unmark_all', message: 'Desmarcar todos os vértices' });
  steps.push({ type: 'cont_init', message: 'cont = 0' });
  
  let tempMarked = {};
  let tempExpl = {};
  let tempCont = 0;
  
  steps.push({ type: 'bfs_call', v: 1, message: 'Chamar BFS(1)' });
  steps.push({ type: 'new_tree', root: 1, message: '--- Nova árvore BFS com raiz 1 ---' });
  
  simulateBFS(1, tempMarked, tempExpl, tempCont, steps);
  tempCont = steps.filter(s => s.type === 'expl').length;
  
  for (let v of vertices) {
    if (!tempMarked[v]) {
      steps.push({ type: 'check_unmarked', v: v, message: `Verificar vértice ${v}: desmarcado` });
      steps.push({ type: 'bfs_call', v: v, message: `Chamar BFS(${v})` });
      steps.push({ type: 'new_tree', root: v, message: `--- Nova árvore BFS com raiz ${v} ---` });
      
      simulateBFS(v, tempMarked, tempExpl, tempCont, steps);
      tempCont = steps.filter(s => s.type === 'expl').length;
    } else {
      steps.push({ type: 'check_marked', v: v, message: `Verificar vértice ${v}: já marcado` });
    }
  }
  
  steps.push({ type: 'complete', message: 'TravessiaBFS completo!' });
}

function simulateBFS(startV, tempMarked, tempExpl, tempCont, steps) {
  steps.push({ type: 'mark', v: startV, message: `Marcar vértice ${startV}` });
  tempMarked[startV] = true;
  
  tempCont++;
  steps.push({ type: 'expl', v: startV, cont: tempCont, message: `expl[${startV}] = ++cont = ${tempCont}` });
  tempExpl[startV] = tempCont;
  
  steps.push({ type: 'enqueue', v: startV, message: `Enfileirar ${startV}` });
  
  let tempQueue = [startV];
  
  while (tempQueue.length > 0) {
    let curr = tempQueue.shift();
    steps.push({ type: 'dequeue', v: curr, message: `curr = ${curr} (dequeue)` });
    steps.push({ type: 'explore', v: curr, message: `Explorando vértice ${curr}` });
    
    for (let u of adjList[curr]) {
      if (!tempMarked[u]) {
        tempMarked[u] = true;
        tempCont++;
        tempExpl[u] = tempCont;
        tempQueue.push(u);
        
        steps.push({ type: 'check', from: curr, to: u, message: `Aresta <${curr},${u}>: ${u} está desmarcado` });
        steps.push({ type: 'mark', v: u, message: `Marcar vértice ${u}` });
        steps.push({ type: 'expl', v: u, cont: tempCont, message: `expl[${u}] = ++cont = ${tempCont}` });
        steps.push({ type: 'tree_edge', from: curr, to: u, message: `Adicionar aresta ${curr}->${u} à árvore` });
        steps.push({ type: 'enqueue', v: u, message: `Enfileirar ${u}` });
      } else {
        steps.push({ type: 'check', from: curr, to: u, message: `Aresta <${curr},${u}>: ${u} já marcado` });
      }
    }
  }
}

function stepSimulation() {
  if (stepIndex >= steps.length) return;
  
  if (!simulationStarted) {
    simulationStarted = true;
    document.getElementById('stateDisplay').style.display = 'block';
  }
  
  let step = steps[stepIndex];
  let output = document.getElementById('output').textContent;
  
  switch(step.type) {
    case 'init':
    case 'unmark_all':
    case 'cont_init':
    case 'bfs_call':
    case 'check_unmarked':
    case 'check_marked':
      output += step.message + '\n';
      break;
      
    case 'new_tree':
      treeRoots.push(step.root);
      currentBFSRoot = step.root;
      output += '\n' + step.message + '\n';
      break;
      
    case 'mark':
      marked[step.v] = true;
      output += step.message + '\n';
      break;
      
    case 'expl':
      expl[step.v] = step.cont;
      cont = step.cont;
      output += step.message + '\n';
      break;
      
    case 'tree_edge':
      treeEdges.push([step.from, step.to]);
      output += step.message + '\n';
      break;
      
    case 'enqueue':
      queue.push(step.v);
      output += step.message + '\n';
      break;
      
    case 'dequeue':
      curr = queue.shift();
      output += step.message + '\n';
      break;
      
    case 'explore':
      output += step.message + '\n';
      break;
      
    case 'check':
      output += step.message + '\n';
      break;
      
    case 'complete':
      output += '\n' + step.message + '\n';
      document.getElementById('stepBtn').disabled = true;
      curr = null;
      break;
  }
  
  document.getElementById('output').textContent = output;
  document.getElementById('output').scrollTop = document.getElementById('output').scrollHeight;
  
  updateStateDisplay();
  drawGraph();
  drawTree();
  drawQueue();
  
  stepIndex++;
}

function updateStateDisplay() {
  let varsHtml = `
    <div class="var-display"><strong>cont:</strong> ${cont}</div>
    <div class="var-display"><strong>curr:</strong> ${curr !== null ? curr : 'null'}</div>
    <div class="var-display"><strong>Árvores:</strong> ${treeRoots.length}</div>
  `;
  
  document.getElementById('variables').innerHTML = varsHtml;
  document.getElementById('queueContent').textContent = '[' + queue.join(', ') + ']';
}

window.onload = init;
</script>

</body>
</html>
